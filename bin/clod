#!/bin/env bash
set -euo pipefail

CLOD_VERSION="0.4.11"

reinit=${CLOD_REINIT:-false}
noninteractive=${CLOD_NONINTERACTIVE:-false}
config=${CLOD_CONFIG:-$HOME/.claude.json}

# Compute hash of all files in .clod directory (not subdirectories)
compute_clod_hash() {
  # Hash all regular files in .clod (excluding subdirs like claude/)
  # Sort for consistency, exclude the hash file itself
  find .clod -maxdepth 1 -type f ! -name '.hash' -print0 2>/dev/null \
    | sort -z \
    | xargs -0 sha256sum 2>/dev/null \
    | sha256sum \
    | cut -d' ' -f1
}

changes_detected() {
  local stored_hash=''
  if [[ -f .clod/system/hash ]]; then
    local stored_hash=$(<.clod/system/hash)
  fi

  local current_hash=$(compute_clod_hash)

  if [[ "$stored_hash" == "$current_hash" ]]; then
    return 1
  fi

  return 0
}

save_hash() {
  compute_clod_hash > .clod/system/hash
}

# Compare semantic versions. Returns 0 if $1 > $2, 1 otherwise.
version_gt() {
  local v1=$1 v2=$2
  if [[ "$v1" == "$v2" ]]; then
    return 1
  fi
  local IFS=.
  local i v1_parts=($v1) v2_parts=($v2)
  for ((i=0; i<${#v1_parts[@]}; i++)); do
    local n1=${v1_parts[i]:-0}
    local n2=${v2_parts[i]:-0}
    if ((n1 > n2)); then
      return 0
    elif ((n1 < n2)); then
      return 1
    fi
  done
  return 1
}

# Is this directory initialized?
initialize() {
  mkdir -p .clod/claude
  mkdir -p .clod/system

  # Use an existing config if available.
  if [[ ! -f .clod/claude/claude.json && -f "$config" ]]; then
    cp "$config" .clod/claude/claude.json
  fi

  local cwd=$(pwd)

  if [[ ! -f .clod/name ]]; then
    local name=$(basename "$cwd")
    printf '%s\n' "$name" > .clod/name
  else
    local name=$(<.clod/name)
  fi

  # Create a unique id for this directory so that
  # we can have a short name.
  if [[ ! -f .clod/id ]]; then
    local uuid=$(uuidgen)
    local id=${uuid:0:8}
    printf '%s\n' "$id" > .clod/id
  else
    local id=$(<.clod/id)
  fi

  if [[ ! -f .clod/image ]]; then
    printf '%s\n' "${CLOD_IMAGE:-ubuntu:24.04}" > .clod/image
  fi
  local image=$(<.clod/image)


  cat <<EOF > .clod/system/Dockerfile_base
FROM $image AS base

ARG DEBIAN_FRONTEND=noninteractive
RUN --mount=type=cache,sharing=locked,target=/var/cache/apt \\
    --mount=type=cache,sharing=locked,target=/var/lib/apt \\
    apt-get update \\
 && apt-get install -qq -y npm
EOF

  if [[ ! -f .clod/Dockerfile_project ]]; then
    cat <<EOF > .clod/Dockerfile_project
FROM base AS project

# Uncomment to add project specific dependencies.
#ARG DEBIAN_FRONTEND=noninteractive
#RUN --mount=type=cache,sharing=locked,target=/var/cache/apt \\
#    --mount=type=cache,sharing=locked,target=/var/lib/apt \\
#    apt-get update \\
# && apt-get install -qq -y npm
EOF
  fi

  cat <<'EOF' > .clod/system/Dockerfile_wrapper
FROM project AS wrapper

COPY <<DEOF /usr/bin/claude-wrapper
#!/bin/bash
set -euo pipefail

if [[ -f ~/.claude/claude.json ]]; then
  cp ~/.claude/claude.json ~/.claude.json
fi

trap 'cp ~/.claude.json ~/.claude/claude.json' EXIT

# Read default flags from .clod/claude-default-flags if it exists.
if [[ -f .clod/claude-default-flags ]]; then
  eval "claude \$(<.clod/claude-default-flags) \"\$@\""
else
  claude "\$@"
fi
DEOF
RUN chmod u+x /usr/bin/claude-wrapper

ARG GROUP_ID
ARG GROUP_NAME
ARG USER_ID
ARG USER_NAME

# Skip user/group operations if running as root (UID 0)
RUN if [ "$USER_ID" != "0" ]; then \
      (groupdel $(getent group "$GROUP_ID" | cut -d: -f1) || true) \
      && (userdel $(getent passwd "$USER_ID" | cut -d: -f1) || true) \
      && groupadd -g "$GROUP_ID" "$GROUP_NAME" \
      && useradd -m -u "$USER_ID" -g "$GROUP_NAME" "$USER_NAME"; \
    fi

# Set home directory based on user (root uses /root, others use /home/$USER_NAME)
ARG USER_HOME
USER $USER_NAME
WORKDIR $USER_HOME

RUN mkdir -p ~/.npm \
 && npm config set prefix ~/.npm \
 && npm install -g @anthropic-ai/claude-code
ENV HOME="$USER_HOME"
ENV USER="$USER_NAME"
ENV PATH="$PATH:$USER_HOME/bin:$USER_HOME/.npm/bin"

ENTRYPOINT ["claude-wrapper"]
EOF

  cat <<'EOF' > .clod/system/build
#!/bin/env bash
set -euo pipefail

name=$(<.clod/name)
id=$(<.clod/id)

# Who are you?
user_id=$(id -u)
user_name=$(id -nu)
group_id=$(id -g)
group_name=$(id -gn)

# Set home directory based on user (root uses /root, others use /home/$user_name)
if [ "$user_id" = "0" ]; then
  user_home="/root"
else
  user_home="/home/$user_name"
fi

cat .clod/system/Dockerfile_base .clod/Dockerfile_project .clod/system/Dockerfile_wrapper > .clod/system/Dockerfile

exec docker build \
  --build-arg "USER_ID=$user_id" \
  --build-arg "USER_NAME=$user_name" \
  --build-arg "GROUP_ID=$group_id" \
  --build-arg "GROUP_NAME=$group_name" \
  --build-arg "USER_HOME=$user_home" \
  -t "clod-${name,,}-$id" \
  -f .clod/system/Dockerfile \
  .
EOF
  chmod u+x .clod/system/build

  cat <<EOF > .clod/system/run
#!/bin/env bash
set -euo pipefail

cwd=\$(pwd)
name=\$(<.clod/name)
id=\$(<.clod/id)
user_id=\$(id -u)
user_name=\$(id -nu)

# Set home directory based on user (root uses /root, others use /home/\$user_name)
if [[ "\$user_id" == "0" ]]; then
  user_home="/root"
else
  user_home="/home/\$user_name"
fi

if [[ -v CLOD_ENTRYPOINT ]]; then
  entrypoint="--entrypoint \$CLOD_ENTRYPOINT"
fi

if [[ -t 0 ]]; then
  tty_flag="-it"
fi

# Pass through MCP timeout if set (for permission prompts)
if [[ -v MCP_TOOL_TIMEOUT ]]; then
  mcp_env="-e MCP_TOOL_TIMEOUT=\$MCP_TOOL_TIMEOUT"
fi

# Determine default concurrency from .clod/concurrent file
concurrent_default="false"
if [[ -f .clod/concurrent ]]; then
  concurrent_file=\$(<.clod/concurrent)
  if [[ "\$concurrent_file" == "true" ]]; then
    concurrent_default="true"
  fi
fi

# Allow CLOD_CONCURRENT to override the default
concurrent="\${CLOD_CONCURRENT:-\$concurrent_default}"

# SSH credential forwarding support
ssh_default="false"
if [[ -f .clod/ssh ]]; then
  ssh_file=\$(<.clod/ssh)
  if [[ "\$ssh_file" == "true" ]]; then
    ssh_default="true"
  elif [[ "\$ssh_file" != "false" ]]; then
    # Not true/false, treat as potential key file path
    ssh_default="\$ssh_file"
  fi
fi

# Allow CLOD_SSH to override the default
ssh="\${CLOD_SSH:-\$ssh_default}"

# Variable to track if we started our own agent
clod_ssh_agent_started="false"

if [[ "\$ssh" == "true" ]]; then
  # Use existing SSH agent
  # Detect platform and set SSH socket path
  if [[ -e /run/host-services/ssh-auth.sock ]]; then
    # macOS with Docker Desktop
    ssh_socket="/run/host-services/ssh-auth.sock"
  elif [[ -v SSH_AUTH_SOCK ]]; then
    # Linux or macOS with SSH_AUTH_SOCK set
    ssh_socket="\$SSH_AUTH_SOCK"
  fi

  # Only set SSH forwarding if we found a socket
  if [[ -n "\$ssh_socket" ]]; then
    ssh_volume="-v \$ssh_socket:\$ssh_socket"
    ssh_env="-e SSH_AUTH_SOCK=\$ssh_socket"
  fi
elif [[ "\$ssh" != "false" ]]; then
  # Treat as a key file path - expand tilde and validate
  # Use eval to properly expand tilde
  eval ssh_key_file="\$ssh"

  echo "[clod] SSH key file specified: \$ssh" >&2
  echo "[clod] Expanded SSH key file: \$ssh_key_file" >&2

  if [[ -f "\$ssh_key_file" ]]; then
    echo "[clod] Starting dedicated SSH agent..." >&2

    # Start a dedicated SSH agent with only this key
    # Create a temporary directory for the agent socket to avoid conflicts
    clod_ssh_tmpdir="\$(mktemp -d -t clod-ssh-agent.XXXXXXXXXX)"
    clod_ssh_socket="\$clod_ssh_tmpdir/agent.sock"

    # ssh-agent needs a clean environment without SSH_AUTH_SOCK set
    unset SSH_AUTH_SOCK
    ssh_agent_output=\$(ssh-agent -s -a "\$clod_ssh_socket" 2>&1)
    echo "[clod] SSH agent output: \$ssh_agent_output" >&2
    eval "\$ssh_agent_output"

    echo "[clod] SSH_AUTH_SOCK after agent start: \$SSH_AUTH_SOCK" >&2
    echo "[clod] SSH_AGENT_PID: \$SSH_AGENT_PID" >&2

    # Add the specified key to the agent
    echo "[clod] Adding key \$ssh_key_file to agent..." >&2
    ssh_add_output=\$(ssh-add "\$ssh_key_file" 2>&1) || ssh_add_status=\$?

    if [[ -z "\${ssh_add_status:-}" ]]; then
      echo "[clod] Successfully added key to agent" >&2
      echo "[clod] ssh-add output: \$ssh_add_output" >&2
      clod_ssh_agent_started="true"
      ssh_socket="\$SSH_AUTH_SOCK"
      ssh_volume="-v \$ssh_socket:\$ssh_socket"
      ssh_env="-e SSH_AUTH_SOCK=\$ssh_socket"

      # Store the agent PID for cleanup
      clod_ssh_agent_pid="\$SSH_AGENT_PID"
    else
      echo "[clod] Failed to add key to agent (exit code: \$ssh_add_status)" >&2
      echo "[clod] ssh-add output: \$ssh_add_output" >&2
      # Kill the agent we just started since we can't use it
      kill "\$SSH_AGENT_PID" 2>/dev/null || true
    fi
  else
    echo "[clod] SSH key file not found: \$ssh_key_file" >&2
  fi
fi

# GPU support
gpus_value=""
if [[ -v CLOD_GPUS ]]; then
  # Environment variable takes priority
  gpus_value="\$CLOD_GPUS"
elif [[ -f .clod/gpus ]]; then
  # Use value from .clod/gpus file
  gpus_value=\$(<.clod/gpus)
else
  # Auto-detect: test if --gpus flag works
  if docker run --gpus all --rm hello-world &>/dev/null; then
    gpus_value="all"
  fi
fi

# Set the GPU flag if we have a value
if [[ -n "\$gpus_value" ]]; then
  gpus_flag="--gpus \$gpus_value"
fi

# Generate unique suffix for concurrent mode
runtime_suffix=""
if [[ "\$concurrent" == "true" ]]; then
  # Use provided suffix or generate one
  if [[ -v CLOD_RUNTIME_SUFFIX ]]; then
    runtime_suffix="-\$CLOD_RUNTIME_SUFFIX"
  else
    # Generate 6 random hex characters
    runtime_suffix="-\$(head -c 3 /dev/urandom | xxd -p)"
  fi
fi

# Determine runtime directory and create it
runtime_dir=".clod/runtime\${runtime_suffix}"
mkdir -p "\$runtime_dir"

# Set up cleanup trap to remove runtime directory and kill SSH agent on exit
cleanup() {
  rm -rf "\$runtime_dir"
  if [[ "\$clod_ssh_agent_started" == "true" ]] && [[ -n "\$clod_ssh_agent_pid" ]]; then
    kill "\$clod_ssh_agent_pid" 2>/dev/null || true
  fi
  if [[ -n "\${clod_ssh_tmpdir:-}" ]] && [[ -d "\$clod_ssh_tmpdir" ]]; then
    rm -rf "\$clod_ssh_tmpdir"
  fi
}
trap cleanup EXIT

# Always name the container, adding suffix in concurrent mode
container_name="--name clod-\${name,,}-\$id\${runtime_suffix}"

docker run \${tty_flag:-} --rm \\
  \${container_name} \\
  --hostname "clod-\$name-\$id" \\
  -v "\$cwd:\$cwd" \\
  -v "\$cwd/.clod:\$cwd/.clod:ro" \\
  -v "\$cwd/\$runtime_dir:\$cwd/\$runtime_dir:rw" \\
  -v "\$cwd/.clod/claude:\$user_home/.claude" \\
  \${ssh_volume:-} \\
  -w "\$cwd" \\
  -e "CLOD_RUNTIME_DIR=\$runtime_dir" \\
  \${mcp_env:-} \\
  \${ssh_env:-} \\
  \${gpus_flag:-} \\
  \${entrypoint:-} \\
  "clod-\${name,,}-\$id" "\$@"
EOF
  chmod u+x .clod/system/run

  # Store the version used to initialize
  printf '%s\n' "$CLOD_VERSION" > .clod/system/version
  save_hash
}

# Migrate old installations to new structure FIRST
migrate_to_system_dir() {
  # Check if migration needed (system dir doesn't exist)
  if [[ ! -d .clod/system ]]; then
    printf 'Migrating .clod structure to v%s...\n' "$CLOD_VERSION"

    # Create system directory
    mkdir -p .clod/system

    # Move system files to new location
    [[ -f .clod/Dockerfile_base ]] && mv .clod/Dockerfile_base .clod/system/
    [[ -f .clod/Dockerfile_wrapper ]] && mv .clod/Dockerfile_wrapper .clod/system/
    [[ -f .clod/Dockerfile ]] && mv .clod/Dockerfile .clod/system/
    [[ -f .clod/build ]] && mv .clod/build .clod/system/
    [[ -f .clod/run ]] && mv .clod/run .clod/system/
    [[ -f .clod/version ]] && mv .clod/version .clod/system/
    [[ -f .clod/.hash ]] && mv .clod/.hash .clod/system/hash
    [[ -f .clod/hash ]] && mv .clod/hash .clod/system/

    printf 'Migration complete.\n'
  fi
}

# Run migration before checking upgrade needs
if [[ -d .clod ]]; then
  migrate_to_system_dir
fi

# Check if we need to initialize or upgrade
needs_init=false
needs_upgrade=false

if [[ ! -d .clod ]]; then
  needs_init=true
elif [[ $reinit == 'true' ]]; then
  needs_init=true
elif changes_detected; then
  printf 'Detected changes in .clod files, reinitializing...\n'
  needs_upgrade=true
elif [[ ! -f .clod/system/version ]]; then
  needs_upgrade=true
else
  installed_version=$(<.clod/system/version)
  if version_gt "$CLOD_VERSION" "$installed_version"; then
    needs_upgrade=true
  fi
fi

if [[ $needs_init == 'true' ]]; then
  if [[ $noninteractive == 'true' ]]; then
    printf 'ERROR: .clod directory not initialized. Run clod interactively first.\n' >&2
    exit 1
  fi
  read -p "Initialize the .clod directory? [Y/n] " yn
  case $yn in
    [Yy]* | '')
      printf 'Initializing clod v%s...\n' "$CLOD_VERSION"
      initialize
      ;;
    *)
      exit
      ;;
  esac
elif [[ $needs_upgrade == 'true' ]]; then
  installed_version=${installed_version:-"unknown"}
  printf 'Upgrading clod from v%s to v%s...\n' "$installed_version" "$CLOD_VERSION"
  initialize
fi

# It's go time!
.clod/system/build
exec .clod/system/run "$@"
